:: namespace SomeNameSpace
:: classname SomeClass

extends One.Two.Three.Four.Five

constructor(i, j, Int ...a){ print(j); print(j) }
constructor(){}
constructor(){}

# Is there ... in constructor params?
# Can it appear anywhere or just at the end?
# is "j = 10" a valid way to specify params, or must there always be a type, except for initialization?

let Int i = 0
let j = 1

# Needs to be assigned in constructor
let Int innerClassMember

# Can only have one at most
constructor(Int i, innerClassMember, Int j) {
  print(i, j)
}

let Int thereCanBeDeclarationsInBetween = 0

# Can only have one at most (can be before constructor())
__constructor() {}

# Can't do file directives after code:
#   :: namespace Whatever

let Func(Int a, Int b : Int) fn = Func(Int a, Int b : Int) {
	return a + b
}

# const values are forward declared (and so is type), so thats okay, but not let
const fn1 = Func(:){fn2()}
const fn2 = Func(:){fn1()}

const my_array = Array(Int, 5){ 10, 20, 30, 40, 50 }

fn(b = 20, a = 30)
fn(30, _)
fn(_, _, 30)
fn()
fn(30)

let Func(Int, Int : Int) fn = Func(a, b) {
	return a + b
}

let fn = Func(Int a, Int b : Int) {
	return a + b
}

let Func(Int a, Int b : Int) fn = { return a + b }

const ls = List(Int){ 10, 20 }



let casting = Func(:) {
	120.5 as Float; some_obj as SomeClass
}

{
	3
}

let misc = Func(Int a:) {
	let Int | String i = select (a == 10: 27, true: "lmao")
	# i is now either `27` or `"lmao"`
	{
		defer print("3rd")
		defer print("2nd")
		defer print("1st")
		yield 10
	} # prints 1st, 2nd, 3rd at the end of this scope
	print(ls[
		2
		+
		3
	])
	let interpolated = "hello {some_var} <- that's a var"
	(
		2
		+
		3
	)
	# This aint allowed bitch
	#   2
	#   +
	#   3
	# But this is :D
	print(
		2
		+
		3
	)
	# But again, this isn't
	#   print
	#   (2 + 3)
}

let control_flow = Func(:) {
	iterate ls -> index, elem { }
	iterate ls -> elem {
		continue
	}
	iterate ls {
		break
	}

	loop from 0 to 10 { }
	loop from 0 to 10 -> i { }
	loop from 0 to 10 by 2 { }
	loop from 0 to 10 by 2 -> u { }
	loop to 10 by 2 { }
	loop to 10 by 2 -> i {} 
	loop to 10 { }
	loop to 10 -> i { }
	while true { }

	while true { }; print("hello") # That is allowed, though

	# if statements
	if some_bool_expr {
		print("this code block runs when true")
	} elif another_bool_expr {
		print("this block runs when the first was false, but the second is true")
	} else {
		print("this block runs when all of the tests were false")
	}

	# if some_bool_expr {
		# code
	# } else if another_bool { # THIS LINE IS INVALID, MUST BE 'elif'
		# code
	# }

	# if expressions (like our old if, but without codeblocks)
	#   each branch can only contain one expression, no statements allowed!
	let mut value = select (x > 0: "bigger", x < 0: "smaller", true: "zero")

	select(false: "never", false: "still never", true: "always")
	select [x] (10: "if x is 10", 20: "if x is 20", 30: "if x is 30", x: "always")

	# switch statements
	switch some_int case 10 {
		print("ten")
	} case 20 {
		print("definitely twenty")
	} case 20, 30, 40 {
		print("maybe twenty, thirty or forty")
	} else {
		print("the number didn't match any of our checks")
	}
}

@a_decorator
let class_stuff = Func(:) {
	# This is abstract
	type One = Class(
		# This is an abstract  
		let Int i
	)

	type Two = Class(
		extends One
		i = 10 # implement i

		# constructor makes it concrete
		constructor() {}
	)

	type A = Class(
		let fn = Func(:) {
			print("class A")
		}
	)
	type B = Class(
		let fn = Func(:) {
			print("class B")
		}
	)
	type Bottom = Class(
		extends A, B
		
		let Int i
		
		capture(A).fn -> fn_a
		capture(B).fn -> fn_b
		capture(B).fn -> fn_b = Func(:){}
		
		fn_b = Func(:) {
			print("class Bottom")
			super()
		}
		
		let shake_it = Func(:) { print("shake that ass") }
		
		constructor(i) {}
	)

	# making instances :3c
	let btm = Bottom{23}
	btm.shake_it()
	btm.throw_it_back()
	btm.one().two().three(
	).four()[0
		+
		-1
 	].Abcd?.maybe[-1]
 	btm.maybe_func?()
 	btm.maybe_list?[2]
}

@some_decorator()
let math = Func(:) {
	let i = 0
	+i
	-i
	i + 1
	# Assignments are expressions
	i += 1
	i - 1
	i -= 1
	i * 1
	i *= 1
	i / 1
	i /= 1
	i ** 1
	i **= 1
	i // 1
	i //= 1
	i % 1
	i %= 1
	i %% 1
	i %%= 1
	
	let mut s = ""
	s ++ "a string"
	s ++= "a string"

	let String? item = null
	item ??= "hi"
	print(item ?? "it was null")
	item?.upper_case()?.a?.b?.c ?? 0
	
	i | 1
	i |= 1
	i & 1
	i &= 1
	i ~ 1
	i ~= 1
	i ^ 1
	i ^= 1
	i << 1
	i <<= 1
	i >> 1
	i >>= 1
	
	i is Int
	i in a_list
	i > 2 and i < 5
	i > 2 and not i > 4
	i != 4 or some_bool
}

# Can't operate assignment operators, is, in, ., ?.
operator+(MyType mt : MyType) {
	return MyType{inner_number + mt.inner_number}

	# Dictionary
	let my_map = Map(Int, String){
		10: "hi",
		2 * 3 + 6: "a" ++ "b",
		Math.randint(): some_thing as String,
	}
}

# Can't have a declarator in the wild
# @a_decorator
